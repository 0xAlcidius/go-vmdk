
package parser

// Autogenerated code from vmdk_profile.json. Do not edit.

import (
    "encoding/binary"
    "fmt"
    "bytes"
    "io"
    "sort"
    "strings"
    "unicode/utf16"
    "unicode/utf8"
)

var (
   // Depending on autogenerated code we may use this. Add a reference
   // to shut the compiler up.
   _ = bytes.MinRead
   _ = fmt.Sprintf
   _ = utf16.Decode
   _ = binary.LittleEndian
   _ = utf8.RuneError
   _ = sort.Strings
   _ = strings.Join
   _ = io.Copy
)

func indent(text string) string {
    result := []string{}
    lines := strings.Split(text,"\n")
    for _, line := range lines {
         result = append(result, "  " + line)
    }
    return strings.Join(result, "\n")
}


type VMDKProfile struct {
    Off_Misc_a int64
    Off_SparseExtentHeader_magicNumber int64
    Off_SparseExtentHeader_version int64
    Off_SparseExtentHeader_flags int64
    Off_SparseExtentHeader_capacity int64
    Off_SparseExtentHeader_grainSize int64
    Off_SparseExtentHeader_descriptorOffset int64
    Off_SparseExtentHeader_descriptorSize int64
    Off_SparseExtentHeader_numGTEsPerGT int64
    Off_SparseExtentHeader_rgdOffset int64
    Off_SparseExtentHeader_gdOffset int64
    Off_SparseExtentHeader_overHead int64
    Off_SparseExtentHeader_compressAlgorithm int64
}

func NewVMDKProfile() *VMDKProfile {
    // Specific offsets can be tweaked to cater for slight version mismatches.
    self := &VMDKProfile{0,0,4,8,12,20,28,36,44,48,56,64,77}
    return self
}

func (self *VMDKProfile) Misc(reader io.ReaderAt, offset int64) *Misc {
    return &Misc{Reader: reader, Offset: offset, Profile: self}
}

func (self *VMDKProfile) SparseExtentHeader(reader io.ReaderAt, offset int64) *SparseExtentHeader {
    return &SparseExtentHeader{Reader: reader, Offset: offset, Profile: self}
}


type Misc struct {
    Reader io.ReaderAt
    Offset int64
    Profile *VMDKProfile
}

func (self *Misc) Size() int {
    return 0
}

func (self *Misc) a() []uint32 {
   return ParseArray_uint32(self.Profile, self.Reader, self.Profile.Off_Misc_a + self.Offset, 0)
}
func (self *Misc) DebugString() string {
    result := fmt.Sprintf("struct Misc @ %#x:\n", self.Offset)
    return result
}

type SparseExtentHeader struct {
    Reader io.ReaderAt
    Offset int64
    Profile *VMDKProfile
}

func (self *SparseExtentHeader) Size() int {
    return 0
}

func (self *SparseExtentHeader) magicNumber() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_SparseExtentHeader_magicNumber + self.Offset)
}

func (self *SparseExtentHeader) version() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_SparseExtentHeader_version + self.Offset)
}

func (self *SparseExtentHeader) flags() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_SparseExtentHeader_flags + self.Offset)
}

func (self *SparseExtentHeader) capacity() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_SparseExtentHeader_capacity + self.Offset)
}

func (self *SparseExtentHeader) grainSize() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_SparseExtentHeader_grainSize + self.Offset)
}

func (self *SparseExtentHeader) descriptorOffset() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_SparseExtentHeader_descriptorOffset + self.Offset)
}

func (self *SparseExtentHeader) descriptorSize() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_SparseExtentHeader_descriptorSize + self.Offset)
}

func (self *SparseExtentHeader) numGTEsPerGT() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_SparseExtentHeader_numGTEsPerGT + self.Offset)
}

func (self *SparseExtentHeader) rgdOffset() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_SparseExtentHeader_rgdOffset + self.Offset)
}

func (self *SparseExtentHeader) gdOffset() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_SparseExtentHeader_gdOffset + self.Offset)
}

func (self *SparseExtentHeader) overHead() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_SparseExtentHeader_overHead + self.Offset)
}

func (self *SparseExtentHeader) compressAlgorithm() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_SparseExtentHeader_compressAlgorithm + self.Offset)
}
func (self *SparseExtentHeader) DebugString() string {
    result := fmt.Sprintf("struct SparseExtentHeader @ %#x:\n", self.Offset)
    result += fmt.Sprintf("  magicNumber: %#0x\n", self.magicNumber())
    result += fmt.Sprintf("  version: %#0x\n", self.version())
    result += fmt.Sprintf("  flags: %#0x\n", self.flags())
    result += fmt.Sprintf("  capacity: %#0x\n", self.capacity())
    result += fmt.Sprintf("  grainSize: %#0x\n", self.grainSize())
    result += fmt.Sprintf("  descriptorOffset: %#0x\n", self.descriptorOffset())
    result += fmt.Sprintf("  descriptorSize: %#0x\n", self.descriptorSize())
    result += fmt.Sprintf("  numGTEsPerGT: %#0x\n", self.numGTEsPerGT())
    result += fmt.Sprintf("  rgdOffset: %#0x\n", self.rgdOffset())
    result += fmt.Sprintf("  gdOffset: %#0x\n", self.gdOffset())
    result += fmt.Sprintf("  overHead: %#0x\n", self.overHead())
    result += fmt.Sprintf("  compressAlgorithm: %#0x\n", self.compressAlgorithm())
    return result
}

func ParseArray_uint32(profile *VMDKProfile, reader io.ReaderAt, offset int64, count int) []uint32 {
    result := make([]uint32, 0, count)
    for i:=0; i<count; i++ {
      value := ParseUint32(reader, offset)
      result = append(result, value)
      offset += int64(4)
    }
    return result
}

func ParseUint16(reader io.ReaderAt, offset int64) uint16 {
	var buf [2]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint16(data)
}

func ParseUint32(reader io.ReaderAt, offset int64) uint32 {
	var buf [4]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint32(data)
}

func ParseUint64(reader io.ReaderAt, offset int64) uint64 {
	var buf [8]byte
	data := buf[:]
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint64(data)
}

